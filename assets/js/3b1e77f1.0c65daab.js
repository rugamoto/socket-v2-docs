"use strict";(self.webpackChunksocket_v_2_docs=self.webpackChunksocket_v_2_docs||[]).push([[507],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return x}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),c=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=c(e.components);return a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,u=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=c(n),x=r,h=d["".concat(u,".").concat(x)]||d[x]||p[x]||o;return n?a.createElement(h,i(i({ref:t},l),{},{components:n})):a.createElement(h,i({ref:t},l))}));function x(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7970:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return u},default:function(){return x},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:3},u="Executing a route",c={unversionedId:"guides/execute-routes",id:"guides/execute-routes",title:"Executing a route",description:"Once you have decided on a suitable route to execute. You may start engaging the sdk to execute it.",source:"@site/docs/guides/execute-routes.md",sourceDirName:"guides",slug:"/guides/execute-routes",permalink:"/socket-v2-docs/guides/execute-routes",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guides/execute-routes.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Query Routes",permalink:"/socket-v2-docs/guides/query-routes"},next:{title:"API Reference",permalink:"/socket-v2-docs/category/api-reference"}},l={},p=[{value:"Requirements",id:"requirements",level:2},{value:"Execution process",id:"execution-process",level:2},{value:"Pulling transactions",id:"pulling-transactions",level:2},{value:"Full Code",id:"full-code",level:2}],d={toc:p};function x(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"executing-a-route"},"Executing a route"),(0,o.kt)("p",null,"Once you have decided on a suitable route to execute. You may start engaging the sdk to execute it."),(0,o.kt)("p",null,"It's important to first understand what is required to execute a trade."),(0,o.kt)("h2",{id:"requirements"},"Requirements"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Have a user address to execute the trade with"),(0,o.kt)("li",{parentName:"ol"},"Be able to prompt the user for transactions (such as using ",(0,o.kt)("inlineCode",{parentName:"li"},"ethers.js"),")"),(0,o.kt)("li",{parentName:"ol"},"Be able to use rpc providers configured to the requested chain when required by the sdk.")),(0,o.kt)("h2",{id:"execution-process"},"Execution process"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"You start the trade and pull the next transaction to execute"),(0,o.kt)("li",{parentName:"ol"},"The transaction may require an approval, for example when ERC20 tokens are involved. Check if approval is required and execute it using the provided transaction data."),(0,o.kt)("li",{parentName:"ol"},"Retrieve the transaction data for the current transaction and execute it."),(0,o.kt)("li",{parentName:"ol"},"Submit the transaction hash while pulling the next transaction to execute.")),(0,o.kt)("h2",{id:"pulling-transactions"},"Pulling transactions"),(0,o.kt)("p",null,"Assuming you have already ",(0,o.kt)("a",{parentName:"p",href:"/socket-v2-docs/guides/query-routes#querying-the-best-route"},"Selected a route")," to execute"),(0,o.kt)("p",null,"You must first start the quote and retrieve it's generator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const execute = await socket.start(quote);\n")),(0,o.kt)("p",null,"Next you can pull the transactions until they complete using a while loop. Remember to submit the transaction that you executed when retrieving the next transaction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'let next = await execute.next();\nwhile (!next.done && next.value) {\n  const tx = next.value;\n  next = await execute.next("0x000"); // <- The transaction hash of the current transaction\n}\n')),(0,o.kt)("p",null,"For each transaction, you must first check whether it requires an approval. If it does, execute that transaction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const approvalTxData = await tx.getApproveTransaction();\nif (approvalTxData) {\n  const approvalTx = await wallet.sendTransaction(approvalTxData);\n  await approvalTx.wait();\n}\n")),(0,o.kt)("p",null,"If you require to know the chain that this transaction needs to be sent on, it is available at ",(0,o.kt)("inlineCode",{parentName:"p"},"tx.chainId"),"."),(0,o.kt)("p",null,"Next, retrieve the send transaction and send it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const sendTxData = await tx.getSendTransaction();\nconst sendTx = await wallet.sendTransaction(sendTxData);\nawait sendTx.wait();\n")),(0,o.kt)("p",null,"Submit the transaction hash to proceed to the next step:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"next = await execute.next(sendTx.hash);\n")),(0,o.kt)("h2",{id:"full-code"},"Full Code"),(0,o.kt)("p",null,"Finally, it will look something like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const quote = await socket.getBestQuote({ path, amount, address });\nconst execute = await socket.start(quote);\n\nwhile (!next.done && next.value) {\n  const tx = next.value;\n  // Setup the provider and wallet based on `tx.chainId` and `quote.sender` if needed\n  const approvalTxData = await tx.getApproveTransaction();\n  if (approvalTxData) {\n    const approvalTx = await wallet\n      .connect(provider)\n      .sendTransaction(approvalTxData);\n    await approvalTx.wait();\n  }\n  const sendTxData = await tx.getSendTransaction();\n  const sendTx = await wallet.connect(provider).sendTransaction(sendTxData);\n  await sendTx.wait();\n  next = await execute.next(sendTx.hash);\n}\n")))}x.isMDXComponent=!0}}]);